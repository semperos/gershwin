(do
  ;; Functions and macros for common Clojure interop needs
  (defmacro stack-void
    "The keyword :gershwin.core/stack-void is a special value that the compiler will not put on the data stack. Use this to evaluate Clojure but to prevent the return value of the Clojure expression from being added to the stack."
    [& body]
    `(do ~@body ::stack-void))
  ::stack-void)

(stack-void
 (defn gershwin-resolve
   "Resolve the `name` of a Gershwin language form as a var. Gershwin does some mangling of names to prevent clashes with core Clojure forms, so this replicates that."
   [s]
   (let [vr (resolve (symbol s))]
     (if vr
       vr
       (-> s name gershwin.lang.RT/formatGershwinName
           symbol resolve)))))

(stack-void
 (defn gershwin-var
   [s]
   (-> s name gershwin.lang.RT/formatGershwinName
       symbol resolve)))

(stack-void
 (defn print*
   [msg]
   (print msg)
   (.flush *out*)))

(stack-void
 (defn println*
   [msg]
   (println msg)
   (.flush *out*)))

(stack-void
 (defn pr*
   "@todo Even though clojure.lang.RT seems to print out readable forms, Clojure does all the work of pr/prn in core_print.clj, so this function (pr*) should be changed to handle the couple of Gershwin cases here and then defer to Clojure's pr function, instead of this current implementation which uses Gershwin's RT/print which defers to Clojure's RT/print."
   [x]
   (gershwin.lang.RT/print x *out*)))

(stack-void
 (defn prn*
   [x]
   (gershwin.lang.RT/print x *out*)
   (.write *out* "\n")
   (.flush *out*)))

(stack-void
 (defn st-peek [] (Stack/peek)))

(stack-void
 (defn peek* [coll]
   "Like Clojure's peek, but throws an exception if the stack is empty."
   (if (zero? (count coll))
     (throw (Stack$StackUnderflowException. "Data stack underflow. Can't take something off an empty data stack."))
     (peek coll))))

(stack-void
 (defn st-pop [] (Stack/pop)))

(stack-void
 (defn pop-it [] (Stack/popIt)))

(stack-void
 (defn conj-it [x] (Stack/conjMutable x)))

(stack-void
 (defn apply-pop1 [a-fn] (a-fn (pop-it))))

(stack-void
 (defn apply-pop2 [a-fn] (a-fn (pop-it) (pop-it))))

(stack-void
 (defn apply-pop3 [a-fn] (a-fn (pop-it) (pop-it) (pop-it))))

(stack-void
 (defn pop-n-swap2 [a-fn] (let [a (pop-it) b (pop-it)] (a-fn b a))))

(stack-void
 ;; BEGIN Copying of Clojure's core.clj, to allow loading using
 ;; Gershwin's loader instead of Clojure's.
 (defonce ^:dynamic
   ^{:private true
     :doc "A stack of paths currently being loaded by this thread"}
   *pending-paths* ()))

(stack-void
 (defonce ^:dynamic
   ^{:private true :doc "True while a verbose load is pending"}
   *loading-verbosely* false))

(stack-void
 (defn- check-cyclic-dependency
   "Detects and rejects non-trivial cyclic load dependencies. The
    exception message shows the dependency chain with the cycle
    highlighted. Ignores the trivial case of a file attempting to load
    itself because that can occur when a gen-class'd class loads its
    implementation."
   [path]
   (when (some #{path} (rest *pending-paths*))
     (let [pending (map #(if (= % path) (str "[ " % " ]") %)
                        (cons path *pending-paths*))
           chain (apply str (interpose "->" pending))]
       (throw (Exception. (str "Cyclic load dependency: " chain)))))))

(stack-void
 (defn- root-resource
   "Returns the root directory path for a lib"
   {:tag String}
   [lib]
   (str \/
        (.. (name lib)
            (replace \- \_)
            (replace \. \/)))))

(stack-void
 (defn- root-directory
   "Returns the root resource path for a lib"
   [lib]
   (let [d (root-resource lib)]
     (subs d 0 (.lastIndexOf d "/")))))

(stack-void
 ;; need root-directory
 (defn load
   "Loads Clojure code from resources in classpath. A path is interpreted as
    classpath-relative if it begins with a slash or relative to the root
    directory for the current namespace otherwise."
   {:added "1.0"}
   [& paths]
   (doseq [^String path paths]
     (let [^String path (if (.startsWith path "/")
                          path
                          (str (root-directory (ns-name *ns*)) \/ path))]
       (when *loading-verbosely*
         (printf "(clojure.core/load \"%s\")\n" path)
         (flush))
       (check-cyclic-dependency path)
       (when-not (= path (first *pending-paths*))
         (binding [*pending-paths* (conj *pending-paths* path)]
           ;; This is the main departure from Clojure's load
           (gershwin.lang.RT/load (.substring path 1)))))))
 ;; END Copying Clojure's core.clj
 )

! ## Invokables ##

! @todo Clarify use of stack-void here
: invoke [x -- ?] (stack-void (.invoke (pop-it))) ;

: invoke2 [x y -- ?]
  (.invoke (pop-it) (pop-it)) ;

! ## Code loading ##

: load [s --] (stack-void (load (pop-it))) ;

: load-paths [ss --] (apply load (pop-it)) ;

! ## Utilities ##

: clear [] (stack-void (Stack/clear)) ;

: pr [n --] (stack-void (pr* (pop-it))) ;

: prn [n --] (stack-void (prn* (pop-it))) ;

: print [n --] (stack-void (print* (pop-it))) ;

: println [n --] (stack-void (println* (pop-it))) ;

: meta {:added "initial" :doc "Get metadata for TOS. Note that most meaningful metadata is attached to var's that hold the actual values, so you'll need to call `var`"}
  [x -- y]
  (meta (pop-it)) ;

: symbol "Coerce TOS to a symbol"
  [x -- y]
  (symbol (pop-it)) ;

: var "Get var for TOS. Currently uses `resolve` as `var` causes an error."
  [x -- y]
  (gershwin-resolve (pop-it)) ;

: gershwin-var "For vars that share names between Gershwin words and Clojure functions, this removes the ambiguity and attempts to resolve the item as a Gershwin word var."
  [x -- y]
  (gershwin-var (pop-it)) ;

: print-doc "Print documentation metadata for a Gershwin word with the given name" [n --]
  meta :doc invoke2 println ;

! ## Shuffle words ##

! Basics are: drop, swap, dup, rot

: drop "Remove the item at the TOS." [x --] (do (pop-it) ::stack-void) ;

! Common synonym
: . [x --] drop ;

: swap [x y -- y x] (let [a (pop-it) b (pop-it)] (conj-it a) b) ;

: dup [x -- x x] (st-peek) ;

! @todo Will add warnings about using things like rot if/when
!   we get Factor-style dataflow combinators implemented
: rot [x y z -- y z x] (let [a (pop-it) b (pop-it) c (pop-it)] (conj-it b) (conj-it a) c) ;

! Factor extensions to base set

! These include: drop2, drop3, nip, nip2, dup2, dup3, over, over2, pick
! Note: 'pick' differs from what it might mean in most Forths
! @todo Factor implements these as primitives, even though they could be implemented
!   with the basic shuffle words above. Consider.

: drop2 [x y --] drop drop ;

: drop3 [x y z --] drop drop drop ;

: nip [x y -- y] swap drop ;

: nip2 [x y z -- z] swap drop swap drop ;

: dup2 [x y -- x y x y]
  (let [a (st-peek)
        b (peek* (st-pop))]
    (conj-it b) a) ;

: dup3 [x y z -- x y z x y z]
  (let [cdr (st-pop)
        cddr (pop cdr)
        a (st-peek)
        b (peek* cdr)
        c (peek* cddr)]
    (conj-it c) (conj-it b) a) ;

: over [x y -- x y x] (peek* (st-pop)) ;

: over2 [x y z -- x y z x y]
  (let [cdr (st-pop)
        cddr (pop cdr)
        b (peek* cdr)
        c (peek* cddr)]
    (conj-it c) b) ;

: pick [x y z -- x y z x] (peek* (pop (st-pop))) ;

! Basic math

: + [n n -- n] (apply-pop2 +) ;

: - [n n -- n] (pop-n-swap2 -) ;
