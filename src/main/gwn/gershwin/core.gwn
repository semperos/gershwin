(do
  ;; Functions and macros for common Clojure interop needs
  (defmacro stack-void
    "The keyword :gershwin.core/stack-void is a special value that the compiler will not put on the data stack. Use this to evaluate Clojure but to prevent the return value of the Clojure expression from being added to the stack."
    [& body]
    `(do ~@body ::stack-void))
  ::stack-void)

(stack-void
 (defn gershwin-resolve
   "Resolve the `name` of a Gershwin language form as a var. Gershwin does some mangling of names to prevent clashes with core Clojure forms, so this replicates that."
   [s]
   (let [vr (resolve (symbol s))]
     (if vr
       vr
       (-> s name gershwin.lang.RT/formatGershwinName
           symbol resolve)))))

(stack-void
 (defn gershwin-var
   [s]
   (-> s name gershwin.lang.RT/formatGershwinName
       symbol resolve)))

(stack-void
 (defn print*
   [msg]
   (print msg)
   (.flush *out*)))

(stack-void
 (defn println*
   [msg]
   (println msg)
   (.flush *out*)))

(stack-void
 (defn pr*
   "@todo Even though clojure.lang.RT seems to print out readable forms, Clojure does all the work of pr/prn in core_print.clj, so this function (pr*) should be changed to handle the couple of Gershwin cases here and then defer to Clojure's pr function, instead of this current implementation which uses Gershwin's RT/print which defers to Clojure's RT/print."
   [x]
   (gershwin.lang.RT/print x *out*)))

(stack-void
 (defn prn*
   [x]
   (gershwin.lang.RT/print x *out*)
   (.write *out* "\n")
   (.flush *out*)))

(stack-void
 (defn st-peek [] (Stack/peek)))

(stack-void
 (defn peek* [coll]
   "Like Clojure's peek, but throws an exception if the stack is empty."
   (if (zero? (count coll))
     (throw (Stack$StackUnderflowException. "Data stack underflow. Can't take something off an empty data stack."))
     (peek coll))))

(stack-void
 (defn st-pop
   "Call Stack's pop method. Immutable."
   []
   (Stack/pop)))

(stack-void
 (defn pop-it
   "Remove and return the item on TOS. Mutable."
   []
   (Stack/popIt)))

(stack-void
 (defn conj-it
   "Conj the item onto the data stack. Mutable."
   [x] (Stack/conjMutable x)))

(stack-void
 (defn ap1
   "Apply the function to TOS"
   [a-fn] (a-fn (pop-it))))

(stack-void
 (defn ap2
   "Apply the function to the top two items on TOS"
   [a-fn] (a-fn (pop-it) (pop-it))))

(stack-void
 (defn ap3
   "Apply the function to the top three items on TOS"
   [a-fn] (a-fn (pop-it) (pop-it) (pop-it))))

(stack-void
 (defn pop-n-swap
   "Remove top two items from TOS, swap, then apply the function."
   [a-fn] (let [a (pop-it) b (pop-it)] (a-fn b a))))

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! BEGIN Copying of Clojure's core.clj, to allow loading using !
! Gershwin's loader instead of Clojure's.                     !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

(stack-void
 (defonce ^:dynamic
   ^{:private true
     :doc "A stack of paths currently being loaded by this thread"}
   *pending-paths* ()))

(stack-void
 (defonce ^:dynamic
   ^{:private true :doc "True while a verbose load is pending"}
   *loading-verbosely* false))

(stack-void
 (defn- check-cyclic-dependency
   "Detects and rejects non-trivial cyclic load dependencies. The
    exception message shows the dependency chain with the cycle
    highlighted. Ignores the trivial case of a file attempting to load
    itself because that can occur when a gen-class'd class loads its
    implementation."
   [path]
   (when (some #{path} (rest *pending-paths*))
     (let [pending (map #(if (= % path) (str "[ " % " ]") %)
                        (cons path *pending-paths*))
           chain (apply str (interpose "->" pending))]
       (throw (Exception. (str "Cyclic load dependency: " chain)))))))

(stack-void
 (defn- root-resource
   "Returns the root directory path for a lib"
   {:tag String}
   [lib]
   (str \/
        (.. (name lib)
            (replace \- \_)
            (replace \. \/)))))

(stack-void
 (defn- root-directory
   "Returns the root resource path for a lib"
   [lib]
   (let [d (root-resource lib)]
     (subs d 0 (.lastIndexOf d "/")))))

(stack-void
 ;; need root-directory
 (defn load
   "Loads Clojure code from resources in classpath. A path is interpreted as
    classpath-relative if it begins with a slash or relative to the root
    directory for the current namespace otherwise."
   {:added "1.0"}
   [& paths]
   (doseq [^String path paths]
     (let [^String path (if (.startsWith path "/")
                          path
                          (str (root-directory (ns-name *ns*)) \/ path))]
       (when *loading-verbosely*
         (printf "(clojure.core/load \"%s\")\n" path)
         (flush))
       (check-cyclic-dependency path)
       (when-not (= path (first *pending-paths*))
         (binding [*pending-paths* (conj *pending-paths* path)]
           ;; This is the main departure from Clojure's load
           (gershwin.lang.RT/load (.substring path 1))))))))

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! END Copying Clojure's core.clj !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! ## Invokables ##

! @todo Clarify use of stack-void here
: invoke [x -- ?] (stack-void (.invoke (pop-it))) ;

: invoke2 [x y -- ?]
  (.invoke (pop-it) (pop-it)) ;

! ## Code loading ##

: load [s --] (stack-void (ap1 load)) ;

: load-paths [ss --] (apply load (pop-it)) ;

! ## Utilities ##

: clear [] (stack-void (Stack/clear)) ;

: pr [n --] (stack-void (ap1 pr*)) ;

: prn [n --] (stack-void (ap1 prn*)) ;

: print [n --] (stack-void (ap1 print*)) ;

: println [n --] (stack-void (ap1 println*)) ;

: meta {:added "initial" :doc "Get metadata for TOS. Note that most meaningful metadata is attached to var's that hold the actual values, so you'll need to call `var`"}
  [x -- y]
  (ap1 meta) ;

: type "Get an item's type"
  [x -- y]
  (ap1 type) ;

: class "Get an item's class"
  [x -- y]
  (ap1 class) ;

: symbol "Coerce TOS to a symbol"
  [x -- y]
  (ap1 symbol) ;

: var "Get var for TOS. Currently uses `resolve` as `var` causes an error."
  [x -- y]
  (ap1 gershwin-resolve) ;

: gershwin-var "For vars that share names between Gershwin words and Clojure functions, this removes the ambiguity and attempts to resolve the item as a Gershwin word var."
  [x -- y]
  (ap1 gershwin-var) ;

: print-doc "Print documentation metadata for a Gershwin word with the given name" [n --]
  meta :doc invoke2 println ;

! ## Shuffle words ##

! Basics are: drop, swap, dup, rot

: drop "Remove the item at the TOS."
  [x --]
  (do (pop-it) ::stack-void) ;

! Common synonym
: . [x --] drop ;

: swap "Swaps the two items on TOS."
  [x y -- y x]
  (let [y (pop-it)
        x (pop-it)]
    (conj-it y) x) ;

: dup "Duplicate the TOS."
  [x -- x x]
  (st-peek) ;

! @todo Will add warnings about using things like rot, dupd if/when
!   we get Factor-style dataflow combinators implemented
: rot "Rotate the items on TOS as shown in stack effect."
  [x y z -- y z x]
  (let [z (pop-it)
        y (pop-it)
        x (pop-it)]
    (conj-it y) (conj-it z) x) ;

: dupd "Duplicate second item on TOS in-place."
  [x y -- x x y]
  < dup > dip ;

! Factor extensions to base set

! These include: drop2, drop3, nip, nip2, dup2, dup3, over, over2, pick
! Note: 'pick' differs from what it might mean in most Forths
! @todo Factor implements these as primitives, even though they could be implemented
!   with the basic shuffle words above. Consider.

: drop2 "Remove top two items from TOS."
  [x y --]
  drop drop ;

: drop3 "Remove top three items from TOS."
  [x y z --]
  drop drop drop ;

: nip "Remove second element from TOS."
  [x y -- y]
  swap drop ;

: nip2 "Remove second and third elements from TOS."
  [x y z -- z]
  swap drop swap drop ;

: dup2 "Duplicate top two items on TOS."
  [x y -- x y x y]
  (let [y (st-peek)
        x (peek* (st-pop))]
    (conj-it x) y) ;

: dup3 "Duplicate top three items on TOS."
  [x y z -- x y z x y z]
  (let [cdr (st-pop)
        cddr (pop cdr)
        z (st-peek)
        y (peek* cdr)
        x (peek* cddr)]
    (conj-it x) (conj-it y) z) ;

: over "Duplicate second item on TOS."
  [x y -- x y x]
  (peek* (st-pop)) ;

: over2 "Duplicate second and third items on TOS."
  [x y z -- x y z x y]
  (let [cdr (st-pop)
        cddr (pop cdr)
        y (peek* cdr)
        x (peek* cddr)]
    (conj-it x) y) ;

: pick "Duplicate third item on TOS."
  [x y z -- x y z x]
  (peek* (pop (st-pop))) ;

: ? "Choose between t or f depending on truthiness of ?"
  [? t f]
  rot < drop > < nip > if ;

: or "Outputs first truthy value, or false if neither is truthy."
  [x y -- ?]
  dupd ? ;

: and "If both values are true, outputs TOS. Else returns false."
  [x y -- ?]
  over ? ;

! ## Dataflow Combinators ##

! ### Preservering combinators ###

: dip "Remove second item from TOS, execute the quotation on TOS, then restore second item on TOS."
  [x quot -- x]
  (let [quot (pop-it)
        x (pop-it)]
    (.invoke quot)
    x) ;

: dip2 "Remove the second and third items from TOS, execute the quotation on TOS, then restore the second and third items on TOS."
  [x y quot -- x y]
  swap < dip > dip ;

: dip3 "Remove the second, third, and fourth items from TOS, execute the quotation on TOS, then restore the second, third, and fourth items on TOS."
  [x y z quot -- x y z]
  swap < dip2 > dip ;

: dip4 "Remove the second, third, and fourth items from TOS, execute the quotation on TOS, then restore the second, third, and fourth items on TOS."
  [w x y z quot -- w x y z]
  swap < dip3 > dip ;

: keep "As opposed to dip, which removes the second item before executing the quotation, keep keeps the second item on the stack for the quotation's invocation, but then also adds it back again after the quotation has been executed."
  [..a x quot -> ( ..a x -- ..b ) -- ..b x]
  over < invoke > dip ;

: keep2 "Like keep, but restores first and second items on TOS after invoking quotation with them."
  [..a x y quot -> ( ..a x y -- ..b ) -- ..b x y]
  < dup2 > dip dip2 ;

: keep3 "Like keep, but restores first, second, and third items on TOS after invoking quotation with them."
  [..a x y z quot -> ( ..a x y z -- ..b ) -- ..b x y z]
  < dup3 > dip dip3 ;

! ### Cleave combinators ###

! Cleave operators mean: take a single piece of data and apply n number of quotations to it. These are common patterns for repeated uses of `keep`, which should be evident from their implementation.

: bi "Invoke the two quotations on TOS sequentially with the third item on TOS present for both invocations."
  [x p q --]
  < keep > dip invoke ;

: bi2 "Same as bi, but work with two pieces of data."
  [x y p q --]
  < keep2 > dip invoke ;

: bi3 "Same as bi, but work with three pieces of data."
  [x y z p q --]
  < keep3 > dip invoke ;

: tri "Invoke the three quotations on TOS sequentially with the third item on TOS present for all invocations."
  [x p q r --]
  < < keep > dip keep > dip invoke ;

: tri2 "Same as tri, but work with two pieces of data."
  [x y p q r --]
  < < keep2 > dip keep2 > dip invoke ;

: tri3 "Same as tri, but work with three pieces of data."
  [x y z p q r --]
  < < keep3 > dip keep3 > dip invoke ;

! NOTE: The `cleave` word requires words we haven't implemented yet. Punting til later.

! ### Spread combinators ###

! Spread combinators apply n number of quotations to n (or 2*n) number of values. These are common patterns for repeated uses of dip. The asterisk `*` denotes spread combinators.

: bi* "Apply the two quotations to the two values in order."
  [x y p q --]
  < dip > dip invoke ;

: bi2* "Apply p to w and x, then apply q to y and z."
  [w x y z p q --]
  < dip2 > dip invoke ;

: tri* "Apply p to x, q to y, and r to z"
  [x y z p q r --]
  < < dip2 > dip dip > dip invoke ;

: tri2* "Apply p to u and v, q to w and x, and r to y and z"
  [u v w x y z p q r --]
  < dip4 > dip2 bi2* ;

! NOTE: The `spread` word requires words we haven't implemented yet. Punting til later.

! ### Apply combinators ###

! Apply combinators apply a single quotation to multiple values. In this way, they are equivalent to using the spread combinators with each quotation being identical. The ampersand `&` denotes apply combinators (The `@` from Factor cannot be used as a Clojure/Gershwin symbol character).

: bi& "Apply the quotation to the top two items on TOS in order."
  [x y quot --]
  dup bi* ;

: bi2& "Apply the quotation to w and x, and then y and z."
  [w x y z quot --]
  dup bi2* ;

: tri& "Apply the quotation to the top three items on TOS in order."
  [x y z quot --]
  dup dup tri* ;

: tri2& "Apply the quotation to u and v, then to w and x, and finally to y and z."
  [u v w x y z quot --]
  dup dup tri2* ;

! Basic math

: + [n n -- n] (ap2 +) ;

: - [n n -- n] (pop-n-swap -) ;

: * [n n -- n] (ap2 *) ;

: div [n n -- n] (pop-n-swap /) ;
