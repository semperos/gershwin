(do
  ;; Functions and macros for common Clojure interop needs
  (defmacro stack-void [& body] `(do ~@body ::stack-void))
  ::stack-void)

(stack-void
  (defn pop-it [] (Stack/popIt)))

(stack-void
  (defn conj-it [x] (Stack/conjMutable x)))

(stack-void
  (defn pop1 [a-fn] (a-fn (pop-it))))

(stack-void
  (defn pop2 [a-fn] (a-fn (pop-it) (pop-it))))

(stack-void
  (defn pop3 [a-fn] (a-fn (pop-it) (pop-it) (pop-it))))

(stack-void
  (defonce ^:dynamic
    ^{:private true
      :doc "A stack of paths currently being loaded by this thread"}
    *pending-paths* ()))

(stack-void
  (defonce ^:dynamic
    ^{:private true :doc "True while a verbose load is pending"}
    *loading-verbosely* false))

(stack-void
  (defn- check-cyclic-dependency
    "Detects and rejects non-trivial cyclic load dependencies. The
    exception message shows the dependency chain with the cycle
    highlighted. Ignores the trivial case of a file attempting to load
    itself because that can occur when a gen-class'd class loads its
    implementation."
    [path]
    (when (some #{path} (rest *pending-paths*))
      (let [pending (map #(if (= % path) (str "[ " % " ]") %)
                         (cons path *pending-paths*))
            chain (apply str (interpose "->" pending))]
        (throw (Exception. (str "Cyclic load dependency: " chain)))))))

(stack-void
  (defn- root-resource
    "Returns the root directory path for a lib"
    {:tag String}
    [lib]
    (str \/
         (.. (name lib)
             (replace \- \_)
             (replace \. \/)))))

(stack-void
  (defn- root-directory
    "Returns the root resource path for a lib"
    [lib]
    (let [d (root-resource lib)]
      (subs d 0 (.lastIndexOf d "/")))))

(stack-void
  ;; need root-directory
  (defn load
    "Loads Clojure code from resources in classpath. A path is interpreted as
    classpath-relative if it begins with a slash or relative to the root
    directory for the current namespace otherwise."
    {:added "1.0"}
    [& paths]
    (doseq [^String path paths]
      (let [^String path (if (.startsWith path "/")
                             path
                             (str (root-directory (ns-name *ns*)) \/ path))]
        (when *loading-verbosely*
          (printf "(clojure.core/load \"%s\")\n" path)
          (flush))
        (check-cyclic-dependency path)
        (when-not (= path (first *pending-paths*))
          (binding [*pending-paths* (conj *pending-paths* path)]
            ;; This is the main departure from Clojure's load
            (gershwin.lang.RT/load (.substring path 1))))))))

: load [s --] (load (pop-it)) ;

: load-paths [ss --] (apply load (pop-it)) ;

: . [n --] (do (pop-it) ::stack-void) ;

: dup [n -- n n] (let [a (pop-it)] (conj-it a) a) ;

: invoke [] (do (.invoke (pop-it)) ::stack-void) ;

: + [n n -- n] (pop2 +) ;