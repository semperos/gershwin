(do
  ;; Functions and macros for common Clojure interop needs
  (defmacro stack-void
    "The keyword :gershwin.core/stack-void is a special value that the compiler will not put on the data stack. Use this to evaluate Clojure but to prevent the return value of the Clojure expression from being added to the stack."
    [& body]
    `(do ~@body ::stack-void))
  ::stack-void)

(stack-void
  (defn pop-it [] (Stack/popIt)))

(stack-void
  (defn conj-it [x] (Stack/conjMutable x)))

(stack-void
  (defn pop1 [a-fn] (a-fn (pop-it))))

(stack-void
  (defn pop2 [a-fn] (a-fn (pop-it) (pop-it))))

(stack-void
  (defn pop3 [a-fn] (a-fn (pop-it) (pop-it) (pop-it))))

(stack-void
  (defn pop-n-swap2 [a-fn] (let [a (pop-it) b (pop-it)] (a-fn b a))))

(stack-void
  ;; BEGIN Copying of Clojure's core.clj, to allow loading using
  ;; Gershwin's loader instead of Clojure's.
  (defonce ^:dynamic
    ^{:private true
      :doc "A stack of paths currently being loaded by this thread"}
    *pending-paths* ()))

(stack-void
  (defonce ^:dynamic
    ^{:private true :doc "True while a verbose load is pending"}
    *loading-verbosely* false))

(stack-void
  (defn- check-cyclic-dependency
    "Detects and rejects non-trivial cyclic load dependencies. The
    exception message shows the dependency chain with the cycle
    highlighted. Ignores the trivial case of a file attempting to load
    itself because that can occur when a gen-class'd class loads its
    implementation."
    [path]
    (when (some #{path} (rest *pending-paths*))
      (let [pending (map #(if (= % path) (str "[ " % " ]") %)
                         (cons path *pending-paths*))
            chain (apply str (interpose "->" pending))]
        (throw (Exception. (str "Cyclic load dependency: " chain)))))))

(stack-void
  (defn- root-resource
    "Returns the root directory path for a lib"
    {:tag String}
    [lib]
    (str \/
         (.. (name lib)
             (replace \- \_)
             (replace \. \/)))))

(stack-void
  (defn- root-directory
    "Returns the root resource path for a lib"
    [lib]
    (let [d (root-resource lib)]
      (subs d 0 (.lastIndexOf d "/")))))

(stack-void
  ;; need root-directory
  (defn load
    "Loads Clojure code from resources in classpath. A path is interpreted as
    classpath-relative if it begins with a slash or relative to the root
    directory for the current namespace otherwise."
    {:added "1.0"}
    [& paths]
    (doseq [^String path paths]
      (let [^String path (if (.startsWith path "/")
                             path
                             (str (root-directory (ns-name *ns*)) \/ path))]
        (when *loading-verbosely*
          (printf "(clojure.core/load \"%s\")\n" path)
          (flush))
        (check-cyclic-dependency path)
        (when-not (= path (first *pending-paths*))
          (binding [*pending-paths* (conj *pending-paths* path)]
            ;; This is the main departure from Clojure's load
            (gershwin.lang.RT/load (.substring path 1)))))))
  ;; END Copying Clojure's core.clj
  )

: load [s --] (stack-void (load (pop-it))) ;

: load-paths [ss --] (apply load (pop-it)) ;

: . [x --] (do (pop-it) ::stack-void) ;

: dup [x -- x x] (let [a (pop-it)] (conj-it a) a) ;

: invoke [] (do (.invoke (pop-it)) ::stack-void) ;

: + [n n -- n] (pop2 +) ;

: - [n n -- n] (pop-n-swap2 -) ;