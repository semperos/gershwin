(do
  ;; Functions and macros for common Clojure interop needs
  (defmacro stack-void
    "The keyword :gershwin.core/stack-void is a special value that the compiler will not put on the data stack. Use this to evaluate Clojure but to prevent the return value of the Clojure expression from being added to the stack."
    [& body]
    `(do ~@body ::stack-void))
  ::stack-void)

(stack-void
  (defn print*
    "@todo Research why default print disappears"
    [msg]
    (.print (System/out) msg)))

(stack-void
  (defn println*
    "@todo Research why default println disappears"
    [msg]
    (.println (System/out) msg)))

(stack-void
  (defn st-peek [] (Stack/peek)))

(stack-void
  (defn peek* [coll]
    "Like Clojure's peek, but throws an exception if the stack is empty."
    (if (zero? (count coll))
      (throw (Stack$StackUnderflowException. "Data stack underflow. Can't take something off an empty data stack."))
      (peek coll))))

(stack-void
  (defn st-pop [] (Stack/pop)))

(stack-void
  (defn pop-it [] (Stack/popIt)))

(stack-void
  (defn conj-it [x] (Stack/conjMutable x)))

(stack-void
  (defn pop1 [a-fn] (a-fn (pop-it))))

(stack-void
  (defn pop2 [a-fn] (a-fn (pop-it) (pop-it))))

(stack-void
  (defn pop3 [a-fn] (a-fn (pop-it) (pop-it) (pop-it))))

(stack-void
  (defn pop-n-swap2 [a-fn] (let [a (pop-it) b (pop-it)] (a-fn b a))))

(stack-void
  ;; BEGIN Copying of Clojure's core.clj, to allow loading using
  ;; Gershwin's loader instead of Clojure's.
  (defonce ^:dynamic
    ^{:private true
      :doc "A stack of paths currently being loaded by this thread"}
    *pending-paths* ()))

(stack-void
  (defonce ^:dynamic
    ^{:private true :doc "True while a verbose load is pending"}
    *loading-verbosely* false))

(stack-void
  (defn- check-cyclic-dependency
    "Detects and rejects non-trivial cyclic load dependencies. The
    exception message shows the dependency chain with the cycle
    highlighted. Ignores the trivial case of a file attempting to load
    itself because that can occur when a gen-class'd class loads its
    implementation."
    [path]
    (when (some #{path} (rest *pending-paths*))
      (let [pending (map #(if (= % path) (str "[ " % " ]") %)
                         (cons path *pending-paths*))
            chain (apply str (interpose "->" pending))]
        (throw (Exception. (str "Cyclic load dependency: " chain)))))))

(stack-void
  (defn- root-resource
    "Returns the root directory path for a lib"
    {:tag String}
    [lib]
    (str \/
         (.. (name lib)
             (replace \- \_)
             (replace \. \/)))))

(stack-void
  (defn- root-directory
    "Returns the root resource path for a lib"
    [lib]
    (let [d (root-resource lib)]
      (subs d 0 (.lastIndexOf d "/")))))

(stack-void
  ;; need root-directory
  (defn load
    "Loads Clojure code from resources in classpath. A path is interpreted as
    classpath-relative if it begins with a slash or relative to the root
    directory for the current namespace otherwise."
    {:added "1.0"}
    [& paths]
    (doseq [^String path paths]
      (let [^String path (if (.startsWith path "/")
                             path
                             (str (root-directory (ns-name *ns*)) \/ path))]
        (when *loading-verbosely*
          (printf "(clojure.core/load \"%s\")\n" path)
          (flush))
        (check-cyclic-dependency path)
        (when-not (= path (first *pending-paths*))
          (binding [*pending-paths* (conj *pending-paths* path)]
            ;; This is the main departure from Clojure's load
            (gershwin.lang.RT/load (.substring path 1)))))))
  ;; END Copying Clojure's core.clj
  )

: load [s --] (stack-void (load (pop-it))) ;

: load-paths [ss --] (apply load (pop-it)) ;

: clear [] (stack-void (Stack/clear)) ;

! ## Shuffle words ##

! Basics are: drop, swap, dup, rot

: drop [x --] (do (pop-it) ::stack-void) ;

! Common synonym
: . [x --] drop ;

: swap [x y -- y x] (let [a (pop-it) b (pop-it)] (conj-it a) b) ;

: dup [x -- x x] (st-peek) ;

! @todo Will add warnings about using things like rot if/when
!   we get Factor-style dataflow combinators implemented
: rot [x y z -- y z x] (let [a (pop-it) b (pop-it) c (pop-it)] (conj-it b) (conj-it a) c) ;

! Factor extensions to base set

! These include: drop2, drop3, nip, nip2, dup2, dup3, over, over2, pick
! Note: 'pick' differs from what it might mean in most Forths
! @todo Factor implements these as primitives, even though they could be implemented
!   with the basic shuffle words above. Consider.

: drop2 [x y --] drop drop ;

: drop3 [x y z --] drop drop drop ;

: nip [x y -- y] swap drop ;

: nip2 [x y z -- z] swap drop swap drop ;

: dup2 [x y -- x y x y]
  (let [a (st-peek)
        b (peek* (st-pop))]
    (conj-it b) a) ;

: dup3 [x y z -- x y z x y z]
  (let [cdr (st-pop)
        cddr (pop cdr)
        a (st-peek)
        b (peek* cdr)
        c (peek* cddr)]
    (conj-it c) (conj-it b) a) ;

: over [x y -- x y x] (peek* (st-pop)) ;

: over2 [x y z -- x y z x y]
  (let [cdr (st-pop)
        cddr (pop cdr)
        b (peek* cdr)
        c (peek* cddr)]
    (conj-it c) b) ;

: pick [x y z -- x y z x] (peek* (pop (st-pop))) ;

! Invokables

: invoke [] (do (.invoke (pop-it)) ::stack-void) ;

! Basic math

: + [n n -- n] (pop2 +) ;

: - [n n -- n] (pop-n-swap2 -) ;
